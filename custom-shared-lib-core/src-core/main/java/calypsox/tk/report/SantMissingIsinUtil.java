package calypsox.tk.report;

import com.calypso.tk.bo.BOMessage;
import com.calypso.tk.bo.Task;
import com.calypso.tk.bo.swift.SwiftFieldMessage;
import com.calypso.tk.bo.swift.SwiftMessage;
import com.calypso.tk.collateral.service.CollateralServiceException;
import com.calypso.tk.collateral.service.ServiceRegistry;
import com.calypso.tk.core.*;
import com.calypso.tk.product.Repo;
import com.calypso.tk.refdata.CollateralConfig;
import com.calypso.tk.refdata.sql.CollateralConfigFilter;
import com.calypso.tk.service.DSConnection;
import com.calypso.tk.service.collateral.CacheCollateralClient;

import java.text.SimpleDateFormat;
import java.util.*;
import java.util.Map.Entry;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

//Project: MISSING_ISIN

/**
 * @author Diego Cano Rodr?guez <diego.cano.rodriguez@accenture.com>
 * @author Carlos Humberto Cejudo Bermejo <c.cejudo.bermejo@accenture.com >
 */
public class SantMissingIsinUtil {
    private static SantMissingIsinUtil instance = null;

    private SantMissingIsinUtil() {
        // Do nothing
    }

    private static final String ISIN_FIELD_TAG = ":35B:";
    private static final String ISIN_FIELD_START = "ISIN";

    private static final String CONTRACT_ID_FIELD_TAG = ":20C:";
    private static final String CONTRACT_ID_FIELD_START = ":CLTR//";
    private static final String CONTRACT_ID_FIELD_END = "--";

    private static final int CONTRACT_ID_RADIX = 36;

    private static final String ISIN_SEC_CODE = "ISIN";

    public static final String MISSING_ISIN_TASK_EVENT = "EX_MISSING_ISIN";

    public static final char COMMENT_ATTRIBUTE_ASSIGNMENT = '=';
    public static final char COMMENT_ATTRIBUTE_SEPARATOR = ';';
    public static final String COMMENT_ATTRIBUTE_ISIN = "ISIN";
    public static final String COMMENT_ATTRIBUTE_AGENT = "Agent";
    public static final String COMMENT_ATTRIBUTE_CPTY = "Cpty";
    public static final String COMMENT_ATTRIBUTE_DATE = "Date";
    public static final String COMMENT_ATTRIBUTE_CONTRACTID = "ContractID";


    public static final String MESSAGE_ATTRIBUTE_COUNTERPARTY = "MissingIsinCounterparty";
    public static final String MESSAGE_ATTRIBUTE_CONTRACTID = "MissingIsinContractID";
    public static final String MESSAGE_ATTRIBUTE_ISIN = "MissingIsinCode";
    public static final String IM_CSD_TYPE = "IM_CSD_TYPE";
    public static final String MESSAGE_ATTRIBUTE_ISREPOTRIPARTY = "RepoTriparty";


    public class SwiftFieldsMap extends HashMap<String, Collection<String>> {
        private static final long serialVersionUID = 1L;
    }

    ;

    public static SantMissingIsinUtil getInstance() {
        if (instance == null) {
            instance = new SantMissingIsinUtil();
        }

        return instance;
    }

    public static void setInstance(SantMissingIsinUtil instance) {
        SantMissingIsinUtil.instance = instance;
    }

    /////////////////////////////////////////////////////////////////////////

    /**
     * Parses all fields in the given SwiftMessage. For each field defined in
     * the given message this method creates a collection containing all the
     * values defined with the same tag. For example, if the tag :16R: is
     * defined twice, the resulting map will contain an entry which key is
     * ":16R:" and which value is a collection with both values.
     *
     * @param message SwiftMessage to be parsed
     * @return A map with every field and value defined in the message.
     */
    public SwiftFieldsMap getAllFields(SwiftMessage message) {
        SwiftFieldsMap fieldsMap = new SwiftFieldsMap();

        for (SwiftFieldMessage field : message.getFields()) {
            String tag = field.getTAG();
            if (!fieldsMap.containsKey(tag)) {
                fieldsMap.put(tag, new ArrayList<String>());
            }
            fieldsMap.get(tag).add(field.getValue());
        }

        return fieldsMap;
    }

    /**
     * Returns all ISIN codes defined in a message.
     *
     * @param fieldsMap A field map as generated by the method getAllFields.
     * @return A collection of ISIN codes.
     */
    public Collection<String> getIsins(SwiftFieldsMap fieldsMap) {
        Collection<String> isins = new ArrayList<String>();

        Collection<String> fieldValues = fieldsMap.get(ISIN_FIELD_TAG);
        if (!Util.isEmpty(fieldValues)) {
            for (String fieldValue : fieldValues) {
                String[] fieldChunks = fieldValue.split("[ \n\r]");
                if (fieldChunks.length >= 2
                        && ISIN_FIELD_START.equals(fieldChunks[0])) {
                    isins.add(fieldChunks[1]);
                }
            }
        }

        return isins;
    }

    /**
     * Returns all ISIN codes contained within a message's attributes.
     *
     * @param message An MT569 BOMessage
     * @return A collection os ISIN codes.
     */
    public Collection<String> getIsins(BOMessage message) {
        Collection<String> isins = new ArrayList<String>();

        int iIsin = 1;
        String isin = message.getAttribute(getIsinMessageAttributeName(iIsin));
        while (!Util.isEmpty(isin)) {
            isins.add(isin);
            iIsin++;
            isin = message.getAttribute(getIsinMessageAttributeName(iIsin));
        }

        return isins;
    }

    /**
     * Returns a contract id defined in a message.
     *
     * @param fieldsMap A field map as generated by the method getAllFields.
     * @return TripartyContract whit id.
     */
    public SantMissingIsinUtilContract getContractId(SwiftFieldsMap fieldsMap, BOMessage message) {
        SantMissingIsinUtilContract contract = new SantMissingIsinUtilContract();

        String tripartyAccountId = message.getAttribute("Triparty Account Id");
        if (!Util.isEmpty(tripartyAccountId)) {
            CollateralConfigFilter collateralConfigFilter = new CollateralConfigFilter();
            collateralConfigFilter.addAdditionalFields("TRIPARTY_ACCOUNT_ID", tripartyAccountId);
            try {
                List<CollateralConfig> marginCallConfigByFilter = ServiceRegistry.getDefault().getCollateralDataServer().getMarginCallConfigByFilter(collateralConfigFilter, true);
                if (marginCallConfigByFilter != null && !marginCallConfigByFilter.isEmpty()) {
                    CollateralConfig fb = marginCallConfigByFilter.get(0);
                    contract.setContractId(fb.getId());
                }
            } catch (Exception e) {
                String messageError = String.format("Could not get Margin Call Config, no triparty_account_id " + tripartyAccountId + " found for any contract");
                Log.error(this, messageError, e);
            }
        } else {
            Pattern patternTriparty = Pattern.compile(
                    CONTRACT_ID_FIELD_START + ".*" + CONTRACT_ID_FIELD_END + ".*");
            Pattern patternRepoTriparty = Pattern.compile(
                    CONTRACT_ID_FIELD_START + "[0-9]+");
            Collection<String> fieldValues = fieldsMap.get(CONTRACT_ID_FIELD_TAG);

            for (String fieldValue : fieldValues) {
                if (!contract.foundContract()) {
                    Matcher matcher = patternTriparty.matcher(fieldValue);
                    if (matcher.matches()) {
                        String matchedGroup = matcher.group();
                        String contractIdBase36 = matchedGroup
                                .substring(CONTRACT_ID_FIELD_START.length());
                        contractIdBase36 = contractIdBase36.substring(0,
                                contractIdBase36.indexOf(CONTRACT_ID_FIELD_END));

                        try {
                            contract.setContractId(Integer.parseInt(contractIdBase36,
                                    CONTRACT_ID_RADIX));
                            break;
                        } catch (NumberFormatException e) {
                            String messageError = String.format(
                                    "Could not parse string \"%s\" as integer with radix %d",
                                    contractIdBase36, CONTRACT_ID_RADIX);
                            Log.error(this, messageError, e);
                        }
                    }else {
                         matcher = patternRepoTriparty.matcher(fieldValue);
                        if (matcher.matches()) {
                            String repoTriparyID = matcher.group().substring(CONTRACT_ID_FIELD_START.length());
                            try {
                                contract.setRepoTripartyId(Long.parseLong(repoTriparyID));
                                break;
                            } catch (NumberFormatException e) {
                                Log.error(this, e);
                            }
                        }
                    }
                }
            }
        }
        return contract;
    }

    /**
     * Checks if an ISIN code is missing in the system.
     *
     * @param isinCode ISIN code to check.
     * @return <code>true</code> if the ISIN is missing, or <code>false</code>
     * otherwise.
     */
    public boolean isMissing(String isinCode) {
        boolean isMissing = false;

        try {
            Product product = DSConnection.getDefault().getRemoteProduct()
                    .getProductByCode(ISIN_SEC_CODE, isinCode);

            isMissing = product == null;
        } catch (CalypsoServiceException e) {
            Log.error(this, e);//Sonar
        }

        return isMissing;
    }

    /**
     * Returns the counterparty short name of a contract defined in a message.
     * @return The short name of the counterparty.
     */
    public String getCounterparty(SantMissingIsinUtilContract contract ) {
        String counterPartyShortName = "";

        if(null!=contract && contract.foundContract()){
            if(contract.isRepoTriparty()){
                try {
                    final Trade repoTriparty = DSConnection.getDefault().getRemoteTrade().getTrade(contract.getRepoTripartyId());
                    if(Optional.ofNullable(repoTriparty).map(Trade::getProduct).filter(Repo.class::isInstance).isPresent()){
                        final LegalEntity counterParty = repoTriparty.getCounterParty();
                        counterPartyShortName = counterParty.getCode();
                    }
                } catch (CalypsoServiceException e) {
                    String message = String.format(
                            "Could not get Repo Triparty with id %d",
                            contract.getRepoTripartyId());
                    Log.error(this, message, e);
                }
            }else {
                try {
                    CollateralConfig collateralConfig = ServiceRegistry.getDefault()
                            .getCollateralDataServer()
                            .getMarginCallConfig(contract.getContractId());
                    if (collateralConfig != null) {
                        LegalEntity counterParty = collateralConfig.getLegalEntity();
                        if (counterParty != null) {
                            counterPartyShortName = counterParty.getCode();
                        }
                    }
                } catch (CollateralServiceException e) {
                    String message = String.format(
                            "Could not get Margin Call Config with id %d",
                            contract.getContractId());
                    Log.error(this, message, e);
                }
            }
        }
        return counterPartyShortName;
    }


    /**
     * Retrieves the counterparty short name from a message's attribute.
     *
     * @param message Message containing the attribute.
     * @return The short name of the counterparty.
     */
    public String getCounterparty(BOMessage message) {
        return message.getAttribute(MESSAGE_ATTRIBUTE_COUNTERPARTY);
    }

    /**
     * Retrieves the id of the Processing Org receiving the given message.
     *
     * @param message Message received by the PO.
     * @return Id of the PO.
     */
    public int getProcessingOrgId(BOMessage message) {
        return message.getReceiverId();
    }

    /**
     * Retrieves the if of the Agent sending the given message.
     *
     * @param message Message sent by the Agent.
     * @return Id of the Agent.
     */
    public int getAgentId(BOMessage message) {
        return message.getSenderId();
    }

    public String getContractId(BOMessage message) {
        String contractId = "";
        if (message != null && !Util.isEmpty(message.getAttribute(MESSAGE_ATTRIBUTE_CONTRACTID))) {
            contractId = message.getAttribute(MESSAGE_ATTRIBUTE_CONTRACTID);
        }
        return contractId;
    }

    /**
     * Retrieves the short name of the Agent sending the given message.
     *
     * @param message Message sent by the Agent.
     * @return Id of the Agent.
     */
    public String getAgentShortName(BOMessage message) {
        String agentShortName = null;

        int agentId = getAgentId(message);
        try {

            agentShortName = DSConnection.getDefault().getRemoteReferenceData()
                    .getLegalEntityCodeById(agentId);
        } catch (CalypsoServiceException e) {
            String errorMessage = String
                    .format("Could not get Legal Entity with id %d", agentId);
            Log.error(this, errorMessage, e);
        }

        return agentShortName;
    }

    /**
     * Returns the current date in the dd/MM/yyyy format.
     *
     * @return Formatted date.
     */
    public String formatCurrentDate() {
        JDate currentDate = getCurrentDate();
        Date date = currentDate.getDate(TimeZone.getDefault());

        SimpleDateFormat sdf = new SimpleDateFormat("dd/MM/yyyy");
        String dateOutput = sdf.format(date);

        return dateOutput;
    }

    /**
     * Returns the current date.
     *
     * @return The current date.
     */
    public JDate getCurrentDate() {
        return JDate.getNow();
    }

    /**
     * Returns the id of a book owned by the given Processing Org.
     *
     * @param poId Id of the Processing Org.
     * @return A book id.
     */
    public int getBookId(int poId) {
        int bookId = 0;

        try {
            Vector<?> rawBooks = DSConnection.getDefault()
                    .getRemoteReferenceData()
                    .getBooks(null, "legal_entity_id = " + poId, null);
            if (rawBooks.size() > 0) {
                if (rawBooks.get(0) instanceof Book) {
                    Book book = (Book) rawBooks.get(0);
                    bookId = book.getId();
                }
            }
        } catch (CalypsoServiceException e) {
            String message = String
                    .format("Could not get books for Legan Entity %d", poId);
            Log.error(this, message, e);
        }

        return bookId;
    }

    /**
     * Transforms a map of attributes into a String to be used as the comment of
     * a missing ISIN Task. The resulting String will have the format
     * "key1=value1;key2=value2".
     *
     * @param commentMap Map containing the attributes.
     * @return A String containing every attribute defined in the map.
     */
    public String printMap(Map<String, String> commentMap) {
        StringBuilder output = new StringBuilder();

        for (Entry<String, String> entry : commentMap.entrySet()) {
            if (output.length() > 0) {
                output.append(COMMENT_ATTRIBUTE_SEPARATOR);
            }
            output.append(entry.getKey());
            output.append(COMMENT_ATTRIBUTE_ASSIGNMENT);
            output.append(entry.getValue());
        }

        return output.toString();
    }

    /**
     * Creates a Task for every missing ISIN code defined in the given message
     * but not in the system.
     *
     * @param message Input message
     * @return A collection of Tasks
     */
    public Collection<Task> createTasks(BOMessage message) {
        Collection<Task> tasks = new ArrayList<Task>();

        Collection<String> isins = getIsins(message);
        for (String isin : isins) {
            if (isMissing(isin)) {
                Task task = createTask(isin, message);
                tasks.add(task);
            }
        }

        return tasks;
    }

    /**
     * Creates a new missing ISIN Task given the ISIN code and the input
     * message.
     *
     * @param isin    ISIN code.
     * @param message Input Message.
     * @return A new Task.
     */
    public Task createTask(String isin, BOMessage message) {
        Task task = new Task();

        // Type: MISSING_ISIN
        task.setStatus(Task.NEW);
        task.setEventClass(Task.EXCEPTION_EVENT_CLASS);
        task.setEventType(MISSING_ISIN_TASK_EVENT);

        // ProcessingOrg Id
        int poId = getProcessingOrgId(message);
        task.setPoId(poId);

        // Agent Id
        int agentId = getAgentId(message);
        task.setLegalEntityId(agentId);

        // Book Id
        int bookId = getBookId(poId);
        task.setBookId(bookId);

        // Comment
        String comment = createTaskComment(isin, message);
        task.setComment(comment);

        return task;
    }

    /**
     * Retrieves all the information needed to generate the Missing ISIN comment
     * and formats the comment.
     *
     * @param isin    Missing ISIN code.
     * @param message Input message.
     * @return Comment of the Task.
     */
    public String createTaskComment(String isin, BOMessage message) {
        String comment = null;
        Map<String, String> commentMap = new HashMap<String, String>();

        // ISIN
        commentMap.put(COMMENT_ATTRIBUTE_ISIN, isin);

        // Agent short name
        String agent = getAgentShortName(message);
        commentMap.put(COMMENT_ATTRIBUTE_AGENT, agent);

        // Counterparty short name
        String counterParty = getCounterparty(message);
        commentMap.put(COMMENT_ATTRIBUTE_CPTY, counterParty);

        // Current date
        String date = formatCurrentDate();
        commentMap.put(COMMENT_ATTRIBUTE_DATE, date);

        // Contract ID
        String contractId = getContractId(message);
        commentMap.put(COMMENT_ATTRIBUTE_CONTRACTID, contractId);

        comment = printMap(commentMap);

        return comment;
    }

    /**
     * Transforms a given comment from a missing ISIN Task into a Map containing
     * all attributes defined in the comment.
     *
     * @param comment Comment from the Task.
     * @return A Map containing all attributes.
     */
    public Map<String, String> getMapFromComment(String comment) {
        Map<String, String> attributesMap = new HashMap<String, String>();

        String[] attributes = comment.split("" + COMMENT_ATTRIBUTE_SEPARATOR);
        for (int iAttribute = 0; iAttribute < attributes.length; iAttribute++) {
            String attribute = attributes[iAttribute];
            String[] keyValue = attribute
                    .split("" + COMMENT_ATTRIBUTE_ASSIGNMENT);
            String key = keyValue[0];
            String value = keyValue[1];

            attributesMap.put(key, value);
        }

        return attributesMap;
    }


    /**
     * Add Contract Group IM/VM and Contract Type
     *
     * @param item
     * @param contractID
     */
    public void addContractInfo(SantMissingIsinItem item, String contractID) {
        if (!Util.isEmpty(contractID)) {
            try {
                CollateralConfig contract = CacheCollateralClient.getCollateralConfig(DSConnection.getDefault(), Integer.valueOf(contractID));
                if (contract != null) {
                    if (contract.getContractGroup().equals("IM") && contract.getContractType().equals("CSD")) {
                        item.setContractType("IM");
                    } else {
                        item.setContractType("VM");
                    }

                    item.setCsdType(!Util.isEmpty(contract.getAdditionalField(IM_CSD_TYPE)) ? contract.getAdditionalField(IM_CSD_TYPE) : "");
                }
            } catch (Exception e) {
                Log.error(this, "Cannot load Contract for: " + item.getIsin());
            }
        }
    }

    /**
     * Returns the name of the message attribute that should be used to store an
     * ISIN code.
     *
     * @param iIsin The index of the ISIN within the message.
     * @return The name of the attribute.
     */
    public String getIsinMessageAttributeName(int iIsin) {
        return MESSAGE_ATTRIBUTE_ISIN + '-' + iIsin;
    }


}
