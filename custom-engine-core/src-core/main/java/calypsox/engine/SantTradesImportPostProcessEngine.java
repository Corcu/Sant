package calypsox.engine;

import calypsox.util.SantReportingUtil;
import com.calypso.engine.Engine;
import com.calypso.tk.bo.workflow.TradeWorkflow;
import com.calypso.tk.core.*;
import com.calypso.tk.event.PSEvent;
import com.calypso.tk.event.PSEventTrade;
import com.calypso.tk.refdata.CollateralConfig;
import com.calypso.tk.service.DSConnection;
import com.calypso.tk.service.collateral.CacheCollateralClient;

import java.util.ArrayList;

/**
 * Engine to complete the trade definition after a trades import
 *
 * @author aela
 */
public class SantTradesImportPostProcessEngine extends Engine {

    /**
     * @param dsCon
     * @param hostName
     * @param port
     */
    public SantTradesImportPostProcessEngine(DSConnection dsCon, String hostName, int port) {
        super(dsCon, hostName, port);
    }

    public static final String ENGINE_NAME = "SantTradesImportPostProcessEngine";

    @Override
    public String getEngineName() {
        return ENGINE_NAME;
    }

    @Override
    public boolean process(PSEvent event) {
        if (isEventToBeProcesses(event)) {
            try {
                PSEventTrade psTrade = (PSEventTrade) event;
                Trade trade = getTrade(psTrade);
                if (trade != null) {
                    ArrayList<Integer> eligibleMarginCallConfigs = SantReportingUtil.getSantReportingService(getDS())
                            .getMarginCallConfigsFromTrade(trade);
                    if (!Util.isEmpty(eligibleMarginCallConfigs)) {
                        for (Integer mccID : eligibleMarginCallConfigs) {
                            CollateralConfig mcc = CacheCollateralClient.getCollateralConfig(getDS(), mccID);
                            if (mcc != null) {
                                CollateralConfig clonedMCC = (CollateralConfig) mcc.clone();
                                clonedMCC.setProdStaticDataFilterName(null);
                                // if the reason for which the trade is in
                                // checked is because of the
                                // ProdStaticDataFilter, then
                                // add a keyword on the trade
                                if (clonedMCC.accept(trade, getDS()) && !mcc.accept(trade, getDS())) {

                                    trade.addKeyword("CHECKED_REASON", "SDF");
                                    saveAmendedTrade(trade);
                                    Log.debug(this, "the trade " + trade.getLongId()
                                            + " was rejected by the SDF of the contract = " + mcc.getId());
                                    break;
                                }
                            }
                        }
                    }
                    getDS().getRemoteTrade().eventProcessed(event.getLongId(), ENGINE_NAME);
                    return true;
                }
            } catch (Exception e) {
                Log.error(this, e);
                return false;
            }
        }
        try {
            // acknowledge the event
            getDS().getRemoteTrade().eventProcessed(event.getLongId(), ENGINE_NAME);
        } catch (Exception e) {
            Log.error(this, e);
            return false;
        }
        return true;
    }

    /**
     * @param event
     * @return true if the received PSEvent is a Statement event generated by the
     * marginCall module
     */
    private boolean isEventToBeProcesses(PSEvent event) {
        boolean eventToBeProcessed = false;
        if (event instanceof PSEventTrade) {
            PSEventTrade psTrade = (PSEventTrade) event;
            Trade trade = psTrade.getTrade();
            if ((trade != null) && (Status.valueOf("CHECKED").equals(trade.getStatus()))) {
                if (Util.isEmpty(trade.getKeywordValue("CHECKED_REASON"))) {
                    eventToBeProcessed = true;
                }
            }
        }
        return eventToBeProcessed;
    }

    /**
     * Gets trade from DataBase with the tradeId which is associated to the Trade
     * received at the PSEventTrade
     *
     * @param psTrade
     * @return Trade trade
     */
    private Trade getTrade(PSEventTrade psTrade) {
        Trade trade = psTrade.getTrade();
        Trade tradeFromDB = null;
        try {
            tradeFromDB = getDS().getRemoteTrade().getTrade(trade.getLongId());
        } catch (CalypsoServiceException e) {
            Log.error(this, "Unable to get trade from DataBase with id=" + trade.getLongId());
            Log.error(this, e);// Sonar
        }
        return tradeFromDB;
    }

    /**
     * Applies Amend Action to the trade and saves the trade
     *
     * @param trade
     */
    private void saveAmendedTrade(final Trade trade) {
        Trade clonedTrade = trade.clone();
        if (isTradeActionApplicable(clonedTrade, Action.AMEND)) {
            clonedTrade.setAction(Action.AMEND);
            try {
                getDS().getRemoteTrade().save(clonedTrade);
            } catch (CalypsoServiceException e) {
                Log.error(this, "Couldn't save trade with id=" + clonedTrade.getLongId());
                Log.error(this, e);// Sonar
            }
        } else {
            Log.error(this, "Amend action is not applicable to the trade with id=" + clonedTrade.getLongId());
        }
    }

    /**
     * Checks if the trade action is applicable.
     *
     * @param transfer the trade
     * @return true if sucess, false otherwise
     */
    protected boolean isTradeActionApplicable(final Trade trade, final Action action) {
        return TradeWorkflow.isTradeActionApplicable(trade, action, DSConnection.getDefault(), null);
    }
}
